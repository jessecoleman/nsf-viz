/**
 * Generated by orval v6.5.0 üç∫
 * Do not edit manually.
 * FastAPI
 * OpenAPI spec version: 0.1.0
 */
import axios,{
  AxiosRequestConfig,
  AxiosResponse,
  AxiosError
} from 'axios';
import {
  useQuery,
  useMutation,
  UseQueryOptions,
  UseMutationOptions,
  QueryFunction,
  MutationFunction,
  UseQueryResult,
  QueryKey
} from 'react-query';
export type GetAbstractAbstractIdGetParams = { terms?: unknown };

export type SearchParams = { org: string; start?: number; end?: number; terms?: string[]; match?: string[]; intersection?: boolean };

export interface YearsResponse {
  per_year: YearAggregate[];
}

export interface YearDivisionAggregate {
  key: number;
  count: number;
  divisions: DivisionAggregate[];
}

export interface YearAggregate {
  key: number;
  count: number;
  amount: number;
}

export interface ValidationError {
  loc: string[];
  msg: string;
  type: string;
}

export interface SubDirectory {
  abbr: string;
  name: string;
  href: string;
  est?: number;
  desc?: string;
}

export interface SearchResponse {
  per_year: YearDivisionAggregate[];
  overall: DivisionAggregate[];
  per_directory: DivisionAggregate[];
}

export interface SearchRequest {
  intersection?: boolean;
  terms: string[];
  org: string;
  divisions: string[];
  match?: string[];
  start?: number;
  end?: number;
}

export interface HTTPValidationError {
  detail?: ValidationError[];
}

export interface GrantsRequest {
  intersection?: boolean;
  terms: string[];
  org: string;
  divisions: string[];
  match?: string[];
  start?: number;
  end?: number;
  idx: number;
  order: string;
  order_by?: string;
}

export interface Grant {
  id: string;
  grant_id: string;
  agency: string;
  score: number;
  title: string;
  date: string;
  amount: number;
  abstract?: string;
  cat1: string;
  cat1_raw: string;
  cat2?: string;
  cat2_raw?: string;
  cat3?: string;
  cat3_raw?: string;
}

export interface DivisionAggregate {
  key: string;
  count: number;
  amount: number;
}

export interface Division {
  key: string;
  name: string;
  selected: boolean;
}

export interface Directory {
  abbr: string;
  name: string;
  href: string;
  est?: number;
  desc?: string;
  departments: SubDirectory[];
}



type AsyncReturnType<
T extends (...args: any) => Promise<any>
> = T extends (...args: any) => Promise<infer R> ? R : any;


/**
 * @summary Divisions
 */
export const loadDivisions = (
  org: string, options?: AxiosRequestConfig
): Promise<AxiosResponse<Division[]>> => {
  return axios.get(
    `/divisions/${org}`,options
  );
};


export const getLoadDivisionsQueryKey = (org: string,) => [`/divisions/${org}`];

    
export const useLoadDivisions = <TData = AsyncReturnType<typeof loadDivisions>, TError = AxiosError<HTTPValidationError>>(
  org: string, options?: { query?:UseQueryOptions<AsyncReturnType<typeof loadDivisions>, TError, TData>, axios?: AxiosRequestConfig}

):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const {query: queryOptions, axios: axiosOptions} = options || {};

  const queryKey = queryOptions?.queryKey ?? getLoadDivisionsQueryKey(org);

  

  const queryFn: QueryFunction<AsyncReturnType<typeof loadDivisions>> = () => loadDivisions(org, axiosOptions);

  const query = useQuery<AsyncReturnType<typeof loadDivisions>, TError, TData>(queryKey, queryFn, {enabled: !!(org), ...queryOptions});

  return {
    queryKey,
    ...query
  };
};


/**
 * @summary Divisions
 */
export const loadDirectory = (
  org: string, options?: AxiosRequestConfig
): Promise<AxiosResponse<Directory[]>> => {
  return axios.get(
    `/directory/${org}`,options
  );
};


export const getLoadDirectoryQueryKey = (org: string,) => [`/directory/${org}`];

    
export const useLoadDirectory = <TData = AsyncReturnType<typeof loadDirectory>, TError = AxiosError<HTTPValidationError>>(
  org: string, options?: { query?:UseQueryOptions<AsyncReturnType<typeof loadDirectory>, TError, TData>, axios?: AxiosRequestConfig}

):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const {query: queryOptions, axios: axiosOptions} = options || {};

  const queryKey = queryOptions?.queryKey ?? getLoadDirectoryQueryKey(org);

  

  const queryFn: QueryFunction<AsyncReturnType<typeof loadDirectory>> = () => loadDirectory(org, axiosOptions);

  const query = useQuery<AsyncReturnType<typeof loadDirectory>, TError, TData>(queryKey, queryFn, {enabled: !!(org), ...queryOptions});

  return {
    queryKey,
    ...query
  };
};


/**
 * @summary Search
 */
export const search = (
  params?: SearchParams, options?: AxiosRequestConfig
): Promise<AxiosResponse<SearchResponse>> => {
  return axios.get(
    '/search',{
      params,
      ...options}
  );
};


export const getSearchQueryKey = (params?: SearchParams,) => ['/search', ...(params ? [params]: [])];

    
export const useSearch = <TData = AsyncReturnType<typeof search>, TError = AxiosError<HTTPValidationError>>(
  params?: SearchParams, options?: { query?:UseQueryOptions<AsyncReturnType<typeof search>, TError, TData>, axios?: AxiosRequestConfig}

):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const {query: queryOptions, axios: axiosOptions} = options || {};

  const queryKey = queryOptions?.queryKey ?? getSearchQueryKey(params);

  

  const queryFn: QueryFunction<AsyncReturnType<typeof search>> = () => search(params, axiosOptions);

  const query = useQuery<AsyncReturnType<typeof search>, TError, TData>(queryKey, queryFn, queryOptions);

  return {
    queryKey,
    ...query
  };
};


/**
 * @summary Years
 */
export const years = (
  searchRequest: SearchRequest, options?: AxiosRequestConfig
): Promise<AxiosResponse<YearsResponse>> => {
  return axios.get(
    '/years',options
  );
};


export const getYearsQueryKey = (searchRequest: SearchRequest,) => ['/years', searchRequest];

    
export const useYears = <TData = AsyncReturnType<typeof years>, TError = AxiosError<HTTPValidationError>>(
  searchRequest: SearchRequest, options?: { query?:UseQueryOptions<AsyncReturnType<typeof years>, TError, TData>, axios?: AxiosRequestConfig}

):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const {query: queryOptions, axios: axiosOptions} = options || {};

  const queryKey = queryOptions?.queryKey ?? getYearsQueryKey(searchRequest);

  

  const queryFn: QueryFunction<AsyncReturnType<typeof years>> = () => years(searchRequest, axiosOptions);

  const query = useQuery<AsyncReturnType<typeof years>, TError, TData>(queryKey, queryFn, queryOptions);

  return {
    queryKey,
    ...query
  };
};


/**
 * @summary Typeahead
 */
export const loadTypeahead = (
  prefix: string, options?: AxiosRequestConfig
): Promise<AxiosResponse<string[]>> => {
  return axios.get(
    `/keywords/typeahead/${prefix}`,options
  );
};


export const getLoadTypeaheadQueryKey = (prefix: string,) => [`/keywords/typeahead/${prefix}`];

    
export const useLoadTypeahead = <TData = AsyncReturnType<typeof loadTypeahead>, TError = AxiosError<HTTPValidationError>>(
  prefix: string, options?: { query?:UseQueryOptions<AsyncReturnType<typeof loadTypeahead>, TError, TData>, axios?: AxiosRequestConfig}

):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const {query: queryOptions, axios: axiosOptions} = options || {};

  const queryKey = queryOptions?.queryKey ?? getLoadTypeaheadQueryKey(prefix);

  

  const queryFn: QueryFunction<AsyncReturnType<typeof loadTypeahead>> = () => loadTypeahead(prefix, axiosOptions);

  const query = useQuery<AsyncReturnType<typeof loadTypeahead>, TError, TData>(queryKey, queryFn, {enabled: !!(prefix), ...queryOptions});

  return {
    queryKey,
    ...query
  };
};


/**
 * @summary Related
 */
export const loadRelated = (
  keywords: string, options?: AxiosRequestConfig
): Promise<AxiosResponse<unknown>> => {
  return axios.get(
    `/keywords/related/${keywords}`,options
  );
};


export const getLoadRelatedQueryKey = (keywords: string,) => [`/keywords/related/${keywords}`];

    
export const useLoadRelated = <TData = AsyncReturnType<typeof loadRelated>, TError = AxiosError<HTTPValidationError>>(
  keywords: string, options?: { query?:UseQueryOptions<AsyncReturnType<typeof loadRelated>, TError, TData>, axios?: AxiosRequestConfig}

):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const {query: queryOptions, axios: axiosOptions} = options || {};

  const queryKey = queryOptions?.queryKey ?? getLoadRelatedQueryKey(keywords);

  

  const queryFn: QueryFunction<AsyncReturnType<typeof loadRelated>> = () => loadRelated(keywords, axiosOptions);

  const query = useQuery<AsyncReturnType<typeof loadRelated>, TError, TData>(queryKey, queryFn, {enabled: !!(keywords), ...queryOptions});

  return {
    queryKey,
    ...query
  };
};


/**
 * @summary Count Term
 */
export const countTerm = (
  terms: string, options?: AxiosRequestConfig
): Promise<AxiosResponse<unknown>> => {
  return axios.get(
    `/keywords/count/${terms}`,options
  );
};


export const getCountTermQueryKey = (terms: string,) => [`/keywords/count/${terms}`];

    
export const useCountTerm = <TData = AsyncReturnType<typeof countTerm>, TError = AxiosError<HTTPValidationError>>(
  terms: string, options?: { query?:UseQueryOptions<AsyncReturnType<typeof countTerm>, TError, TData>, axios?: AxiosRequestConfig}

):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const {query: queryOptions, axios: axiosOptions} = options || {};

  const queryKey = queryOptions?.queryKey ?? getCountTermQueryKey(terms);

  

  const queryFn: QueryFunction<AsyncReturnType<typeof countTerm>> = () => countTerm(terms, axiosOptions);

  const query = useQuery<AsyncReturnType<typeof countTerm>, TError, TData>(queryKey, queryFn, {enabled: !!(terms), ...queryOptions});

  return {
    queryKey,
    ...query
  };
};


/**
 * @summary Grant Data
 */
export const loadGrants = (
  grantsRequest: GrantsRequest, options?: AxiosRequestConfig
): Promise<AxiosResponse<Grant[]>> => {
  return axios.post(
    '/grants',
    grantsRequest,options
  );
};



export const useLoadGrants = <TError = AxiosError<HTTPValidationError>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<AsyncReturnType<typeof loadGrants>, TError,{data: GrantsRequest}, TContext>, axios?: AxiosRequestConfig}
  ) => {
  const {mutation: mutationOptions, axios: axiosOptions} = options || {};

      


  const mutationFn: MutationFunction<AsyncReturnType<typeof loadGrants>, {data: GrantsRequest}> = (props) => {
    const {data} = props || {};

    return  loadGrants(data,axiosOptions);
  };

  return useMutation<AsyncReturnType<typeof loadGrants>, TError, {data: GrantsRequest}, TContext>(mutationFn, mutationOptions);
};
    
/**
 * @summary Grant Download
 */
export const downloadGrants = (
  grantsRequest: GrantsRequest, options?: AxiosRequestConfig
): Promise<AxiosResponse<unknown>> => {
  return axios.post(
    '/grants/download',
    grantsRequest,options
  );
};



export const useDownloadGrants = <TError = AxiosError<HTTPValidationError>,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<AsyncReturnType<typeof downloadGrants>, TError,{data: GrantsRequest}, TContext>, axios?: AxiosRequestConfig}
  ) => {
  const {mutation: mutationOptions, axios: axiosOptions} = options || {};

      


  const mutationFn: MutationFunction<AsyncReturnType<typeof downloadGrants>, {data: GrantsRequest}> = (props) => {
    const {data} = props || {};

    return  downloadGrants(data,axiosOptions);
  };

  return useMutation<AsyncReturnType<typeof downloadGrants>, TError, {data: GrantsRequest}, TContext>(mutationFn, mutationOptions);
};
    
/**
 * @summary Get Abstract
 */
export const loadAbstract = (
  id: unknown,
  terms: unknown, options?: AxiosRequestConfig
): Promise<AxiosResponse<string>> => {
  return axios.get(
    `/abstract/${id}/${terms}`,options
  );
};


export const getLoadAbstractQueryKey = (id: unknown,
  terms: unknown,) => [`/abstract/${id}/${terms}`];

    
export const useLoadAbstract = <TData = AsyncReturnType<typeof loadAbstract>, TError = AxiosError<HTTPValidationError>>(
  id: unknown,
  terms: unknown, options?: { query?:UseQueryOptions<AsyncReturnType<typeof loadAbstract>, TError, TData>, axios?: AxiosRequestConfig}

):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const {query: queryOptions, axios: axiosOptions} = options || {};

  const queryKey = queryOptions?.queryKey ?? getLoadAbstractQueryKey(id,terms);

  

  const queryFn: QueryFunction<AsyncReturnType<typeof loadAbstract>> = () => loadAbstract(id,terms, axiosOptions);

  const query = useQuery<AsyncReturnType<typeof loadAbstract>, TError, TData>(queryKey, queryFn, {enabled: !!(id && terms), ...queryOptions});

  return {
    queryKey,
    ...query
  };
};


/**
 * @summary Get Abstract
 */
export const getAbstractAbstractIdGet = (
  id: unknown,
  params?: GetAbstractAbstractIdGetParams, options?: AxiosRequestConfig
): Promise<AxiosResponse<unknown>> => {
  return axios.get(
    `/abstract/${id}/`,{
      params,
      ...options}
  );
};


export const getGetAbstractAbstractIdGetQueryKey = (id: unknown,
  params?: GetAbstractAbstractIdGetParams,) => [`/abstract/${id}/`, ...(params ? [params]: [])];

    
export const useGetAbstractAbstractIdGet = <TData = AsyncReturnType<typeof getAbstractAbstractIdGet>, TError = AxiosError<HTTPValidationError>>(
  id: unknown,
  params?: GetAbstractAbstractIdGetParams, options?: { query?:UseQueryOptions<AsyncReturnType<typeof getAbstractAbstractIdGet>, TError, TData>, axios?: AxiosRequestConfig}

):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const {query: queryOptions, axios: axiosOptions} = options || {};

  const queryKey = queryOptions?.queryKey ?? getGetAbstractAbstractIdGetQueryKey(id,params);

  

  const queryFn: QueryFunction<AsyncReturnType<typeof getAbstractAbstractIdGet>> = () => getAbstractAbstractIdGet(id,params, axiosOptions);

  const query = useQuery<AsyncReturnType<typeof getAbstractAbstractIdGet>, TError, TData>(queryKey, queryFn, {enabled: !!(id), ...queryOptions});

  return {
    queryKey,
    ...query
  };
};


/**
 * @summary Send Api Json
 */
export const sendApiJsonGenerateOpenapiJsonGet = (
  options?: AxiosRequestConfig
): Promise<AxiosResponse<unknown>> => {
  return axios.get(
    '/generate_openapi_json',options
  );
};


export const getSendApiJsonGenerateOpenapiJsonGetQueryKey = () => ['/generate_openapi_json'];

    
export const useSendApiJsonGenerateOpenapiJsonGet = <TData = AsyncReturnType<typeof sendApiJsonGenerateOpenapiJsonGet>, TError = AxiosError<unknown>>(
  options?: { query?:UseQueryOptions<AsyncReturnType<typeof sendApiJsonGenerateOpenapiJsonGet>, TError, TData>, axios?: AxiosRequestConfig}

):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const {query: queryOptions, axios: axiosOptions} = options || {};

  const queryKey = queryOptions?.queryKey ?? getSendApiJsonGenerateOpenapiJsonGetQueryKey();

  

  const queryFn: QueryFunction<AsyncReturnType<typeof sendApiJsonGenerateOpenapiJsonGet>> = () => sendApiJsonGenerateOpenapiJsonGet(axiosOptions);

  const query = useQuery<AsyncReturnType<typeof sendApiJsonGenerateOpenapiJsonGet>, TError, TData>(queryKey, queryFn, queryOptions);

  return {
    queryKey,
    ...query
  };
};


